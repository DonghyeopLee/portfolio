{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.segmentBounce = exports.calcClosestPtOnSegment = exports.parsePaths = exports.drawPolygonMaskPath = exports.drawPolygonMask = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nfunction drawPolygonMask(context, rawData, stroke) {\n  const color = (0, Utils_1.colorToRgb)(stroke.color);\n\n  if (!color) {\n    return;\n  }\n\n  context.beginPath();\n  context.moveTo(rawData[0].x, rawData[0].y);\n\n  for (const item of rawData) {\n    context.lineTo(item.x, item.y);\n  }\n\n  context.closePath();\n  context.strokeStyle = (0, Utils_1.getStyleFromRgb)(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\n\nexports.drawPolygonMask = drawPolygonMask;\n\nfunction drawPolygonMaskPath(context, path, stroke, position) {\n  context.translate(position.x, position.y);\n  const color = (0, Utils_1.colorToRgb)(stroke.color);\n\n  if (!color) {\n    return;\n  }\n\n  context.strokeStyle = (0, Utils_1.getStyleFromRgb)(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n}\n\nexports.drawPolygonMaskPath = drawPolygonMaskPath;\n\nfunction parsePaths(paths, scale, offset) {\n  var _a;\n\n  const res = [];\n\n  for (const path of paths) {\n    const segments = path.element.pathSegList;\n    const len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0;\n    const p = {\n      x: 0,\n      y: 0\n    };\n\n    for (let i = 0; i < len; i++) {\n      const segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n      const svgPathSeg = window.SVGPathSeg;\n\n      switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n        case svgPathSeg.PATHSEG_MOVETO_ABS:\n        case svgPathSeg.PATHSEG_LINETO_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n        case svgPathSeg.PATHSEG_ARC_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n          {\n            const absSeg = segment;\n            p.x = absSeg.x;\n            p.y = absSeg.y;\n            break;\n          }\n\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n          p.x = segment.x;\n          break;\n\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n          p.y = segment.y;\n          break;\n\n        case svgPathSeg.PATHSEG_LINETO_REL:\n        case svgPathSeg.PATHSEG_MOVETO_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n        case svgPathSeg.PATHSEG_ARC_REL:\n        case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n        case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n          {\n            const relSeg = segment;\n            p.x += relSeg.x;\n            p.y += relSeg.y;\n            break;\n          }\n\n        case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n          p.x += segment.x;\n          break;\n\n        case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n          p.y += segment.y;\n          break;\n\n        case svgPathSeg.PATHSEG_UNKNOWN:\n        case svgPathSeg.PATHSEG_CLOSEPATH:\n          continue;\n      }\n\n      res.push({\n        x: p.x * scale + offset.x,\n        y: p.y * scale + offset.y\n      });\n    }\n  }\n\n  return res;\n}\n\nexports.parsePaths = parsePaths;\n\nfunction calcClosestPtOnSegment(s1, s2, pos) {\n  const {\n    dx,\n    dy\n  } = (0, Utils_1.getDistances)(pos, s1);\n  const {\n    dx: dxx,\n    dy: dyy\n  } = (0, Utils_1.getDistances)(s2, s1);\n  const t = (dx * dxx + dy * dyy) / (dxx ** 2 + dyy ** 2);\n  let x = s1.x + dxx * t;\n  let y = s1.y + dyy * t;\n\n  if (t < 0) {\n    x = s1.x;\n    y = s1.y;\n  } else if (t > 1) {\n    x = s2.x;\n    y = s2.y;\n  }\n\n  return {\n    x: x,\n    y: y,\n    isOnSegment: t >= 0 && t <= 1\n  };\n}\n\nexports.calcClosestPtOnSegment = calcClosestPtOnSegment;\n\nfunction segmentBounce(start, stop, velocity) {\n  const {\n    dx,\n    dy\n  } = (0, Utils_1.getDistances)(start, stop);\n  const wallAngle = Math.atan2(dy, dx);\n  const wallNormalX = Math.sin(wallAngle);\n  const wallNormalY = -Math.cos(wallAngle);\n  const d = 2 * (velocity.x * wallNormalX + velocity.y * wallNormalY);\n  velocity.x -= d * wallNormalX;\n  velocity.y -= d * wallNormalY;\n}\n\nexports.segmentBounce = segmentBounce;","map":{"version":3,"names":["Object","defineProperty","exports","value","segmentBounce","calcClosestPtOnSegment","parsePaths","drawPolygonMaskPath","drawPolygonMask","Utils_1","require","context","rawData","stroke","color","colorToRgb","beginPath","moveTo","x","y","item","lineTo","closePath","strokeStyle","getStyleFromRgb","lineWidth","width","path","position","translate","opacity","paths","scale","offset","_a","res","segments","element","pathSegList","len","numberOfItems","p","i","segment","getItem","svgPathSeg","window","SVGPathSeg","pathSegType","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","absSeg","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","relSeg","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","push","s1","s2","pos","dx","dy","getDistances","dxx","dyy","t","isOnSegment","start","stop","velocity","wallAngle","Math","atan2","wallNormalX","sin","wallNormalY","cos","d"],"sources":["C:/Users/XGaming Systems/Downloads/Portfolio-v2-main/Portfolio_Ian/node_modules/tsparticles/Plugins/PolygonMask/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.segmentBounce = exports.calcClosestPtOnSegment = exports.parsePaths = exports.drawPolygonMaskPath = exports.drawPolygonMask = void 0;\nconst Utils_1 = require(\"../../Utils\");\nfunction drawPolygonMask(context, rawData, stroke) {\n    const color = (0, Utils_1.colorToRgb)(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.beginPath();\n    context.moveTo(rawData[0].x, rawData[0].y);\n    for (const item of rawData) {\n        context.lineTo(item.x, item.y);\n    }\n    context.closePath();\n    context.strokeStyle = (0, Utils_1.getStyleFromRgb)(color);\n    context.lineWidth = stroke.width;\n    context.stroke();\n}\nexports.drawPolygonMask = drawPolygonMask;\nfunction drawPolygonMaskPath(context, path, stroke, position) {\n    context.translate(position.x, position.y);\n    const color = (0, Utils_1.colorToRgb)(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.strokeStyle = (0, Utils_1.getStyleFromRgb)(color, stroke.opacity);\n    context.lineWidth = stroke.width;\n    context.stroke(path);\n}\nexports.drawPolygonMaskPath = drawPolygonMaskPath;\nfunction parsePaths(paths, scale, offset) {\n    var _a;\n    const res = [];\n    for (const path of paths) {\n        const segments = path.element.pathSegList;\n        const len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0;\n        const p = {\n            x: 0,\n            y: 0,\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n            const svgPathSeg = window.SVGPathSeg;\n            switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n                case svgPathSeg.PATHSEG_MOVETO_ABS:\n                case svgPathSeg.PATHSEG_LINETO_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                case svgPathSeg.PATHSEG_ARC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {\n                    const absSeg = segment;\n                    p.x = absSeg.x;\n                    p.y = absSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                    p.x = segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                    p.y = segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_REL:\n                case svgPathSeg.PATHSEG_MOVETO_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                case svgPathSeg.PATHSEG_ARC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {\n                    const relSeg = segment;\n                    p.x += relSeg.x;\n                    p.y += relSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                    p.x += segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                    p.y += segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_UNKNOWN:\n                case svgPathSeg.PATHSEG_CLOSEPATH:\n                    continue;\n            }\n            res.push({\n                x: p.x * scale + offset.x,\n                y: p.y * scale + offset.y,\n            });\n        }\n    }\n    return res;\n}\nexports.parsePaths = parsePaths;\nfunction calcClosestPtOnSegment(s1, s2, pos) {\n    const { dx, dy } = (0, Utils_1.getDistances)(pos, s1);\n    const { dx: dxx, dy: dyy } = (0, Utils_1.getDistances)(s2, s1);\n    const t = (dx * dxx + dy * dyy) / (dxx ** 2 + dyy ** 2);\n    let x = s1.x + dxx * t;\n    let y = s1.y + dyy * t;\n    if (t < 0) {\n        x = s1.x;\n        y = s1.y;\n    }\n    else if (t > 1) {\n        x = s2.x;\n        y = s2.y;\n    }\n    return { x: x, y: y, isOnSegment: t >= 0 && t <= 1 };\n}\nexports.calcClosestPtOnSegment = calcClosestPtOnSegment;\nfunction segmentBounce(start, stop, velocity) {\n    const { dx, dy } = (0, Utils_1.getDistances)(start, stop);\n    const wallAngle = Math.atan2(dy, dx);\n    const wallNormalX = Math.sin(wallAngle);\n    const wallNormalY = -Math.cos(wallAngle);\n    const d = 2 * (velocity.x * wallNormalX + velocity.y * wallNormalY);\n    velocity.x -= d * wallNormalX;\n    velocity.y -= d * wallNormalY;\n}\nexports.segmentBounce = segmentBounce;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}